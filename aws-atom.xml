<feed><id>urn:pro-grammati-ca:feed</id><updated>2020-05-20T00:00:00.000Z</updated><title type="text">pro.grammati.ca</title><link rel="self" href="http://pro.grammati.ca/atom.xml" /><entry><title>Microbucks</title><updated>2020-05-20T00:00:00.000Z</updated><author><name>Chris Perkins</name></author><link href="http://pro.grammati.ca/blog/2020/05/20/microbucks/" /><id>urn:pro-grammati-ca:feed:post:Microbucks</id><content type="html">&lt;h1&gt;Thinking in Microbucks&lt;/h1&gt;&lt;p&gt;When estimating the cost of AWS services, think in microbucks.&lt;/p&gt;&lt;p&gt;What is a microbuck? It is one millionth of a dollar, or one ten-thousandth of a cent.&lt;/p&gt;&lt;p&gt;AWS pricing can be complicated. But when you work it out, it turns out that a lot of commonly-used, pay-per-use services can be pretty well estimated in microbucks (µ$)&lt;/p&gt;&lt;h2&gt;Per-Service Costs&lt;/h2&gt;&lt;p&gt;Note: all of these estimates ignore the free tier.&lt;/p&gt;&lt;h3&gt;Lambda&lt;/h3&gt;&lt;p&gt;Lambda pricing is 0.2 µ$ per request, plus a cost per GB-second. Making two assumptions:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;We use 512 MB of memory, which is pretty reasonable for many lambdas, and&lt;/li&gt;&lt;li&gt;We finish in under 100 ms, and so get billed for 100 ms of time.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Then the cost comes out to about 0.8 µ$. Added to the per-request price, we get a handy rule of thumb:&lt;/p&gt;&lt;p&gt;1 microbuck per lambda invocation.&lt;/p&gt;&lt;h3&gt;API Gateway&lt;/h3&gt;&lt;p&gt;Calls to an HTTP API cost 1 µ$. Simple.&lt;/p&gt;&lt;p&gt;Calls to a REST API cost 3.5 µ$.&lt;/p&gt;&lt;h3&gt;DynamoDB&lt;/h3&gt;&lt;p&gt;With on-demand capacity, writes cost 1.25 µ$ for items under 1 kb. Reads up 4 kb are one tenth of that, so almost free.&lt;/p&gt;&lt;p&gt;Storage is 0.25 µ$ per item per month, assuming 1 kb items. So 3 µ$ per year.&lt;/p&gt;&lt;h3&gt;Events&lt;/h3&gt;&lt;p&gt;Publishing to EventBridge costs 1 µ$ per event.&lt;/p&gt;&lt;p&gt;SQS cost 0.4 µ$, but that's per-call. You'll need 3 calls - publish, then read, then ack. So it also ends up being about a microbuck per message.&lt;/p&gt;&lt;h3&gt;S3&lt;/h3&gt;&lt;p&gt;Write requests cost 5 µ$ each. Read requests are 0.4 µ$.&lt;/p&gt;&lt;p&gt;Storage: for 1 µ$, you can store 40 kb of data for a month.&lt;/p&gt;&lt;h3&gt;CloudWatch Logs&lt;/h3&gt;&lt;p&gt;Half a µ$ per kb logged.&lt;/p&gt;&lt;h3&gt;Step functions&lt;/h3&gt;&lt;p&gt;These are an outlier - they cost 25 µ$ per state transition. That can easily dominate your costs.&lt;/p&gt;&lt;p&gt;Express workflows are priced in a completely different way - you pay 1 µ$ per invocation, plus lambda pricing for the whole duration of the function, start to finish. It's not yet clear to me what you would use express workflows for, so I'll say no more.&lt;/p&gt;&lt;h3&gt;SES&lt;/h3&gt;&lt;p&gt;100 µ$ per email sent. Ouch.&lt;/p&gt;&lt;h2&gt;Examples&lt;/h2&gt;&lt;p&gt;Let's say you have a pretty standard serverless app. You can back-of-the-envelope the costs like this:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Request comes in to API Gateway: 1 µ$&lt;/li&gt;&lt;li&gt;API Gateway invokes a lambda: 1 µ$&lt;/li&gt;&lt;li&gt;Lambda writes an item to DynamoDB: 1 µ$&lt;/li&gt;&lt;li&gt;Lambda does some logging to CloudWatch: 1 µ$&lt;/li&gt;&lt;li&gt;Total: 4 µ$&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;So if your app handles a million requests, it will cost you four bucks.&lt;/p&gt;&lt;p&gt;Another example:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Request comes in to API Gateway: 1 µ$&lt;/li&gt;&lt;li&gt;API Gateway invokes a lambda: 1 µ$&lt;/li&gt;&lt;li&gt;Lambda writes an item to DynamoDB: 1 µ$&lt;/li&gt;&lt;li&gt;Lambda does some logging to CloudWatch: 1 µ$&lt;/li&gt;&lt;li&gt;Lambda publishes an event to EventBridge 1 µ$&lt;/li&gt;&lt;li&gt;Another lambda consumes the event: 1 µ$&lt;/li&gt;&lt;li&gt;Lambda 2 writes some data to S3: 5 µ$&lt;/li&gt;&lt;li&gt;Lambda 2 also does some logging: 1 µ$&lt;/li&gt;&lt;li&gt;Total: 12 µ$&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;So, 12 bucks per million requests.&lt;/p&gt;&lt;p&gt;And one more example:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Request comes in to API Gateway: 1 µ$&lt;/li&gt;&lt;li&gt;API Gateway invokes a lambda: 1 µ$&lt;/li&gt;&lt;li&gt;Lambda starts a step function with 5 states / 4 transitions: 100 µ$&lt;/li&gt;&lt;li&gt;One of the steps sends an email: 100 µ$&lt;/li&gt;&lt;li&gt;The other steps do some stuff, whatever, let's call it another 5 µ$&lt;/li&gt;&lt;li&gt;Total: 207 µ$&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;The step function and the email really killed us.&lt;/p&gt;&lt;p&gt;It's interesting to note that:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Sending a single email can cost much more than all the other things you do in handling a request.&lt;/li&gt;&lt;li&gt;Step Functions can really add up, especially if you have a retry-loop in your state machine. Even in the happy-path, a state machine with just 5 states will cost 100 µ$ per invocation (4 state-transitions), which is huge compared to the simple API example above at 4 µ$. Add in a retry-loop and it can be a whole lot more.&lt;/li&gt;&lt;/ul&gt;</content></entry></feed>