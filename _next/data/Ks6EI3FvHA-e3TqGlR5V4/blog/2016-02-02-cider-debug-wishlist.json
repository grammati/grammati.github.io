{"pageProps":{"post":{"title":"Cider Debug Wishlist","slug":"blog/2016-02-02-cider-debug-wishlist","datePublished":"2016-02-02T00:00:00.000Z","mdx":{"compiledSource":"var c=Object.defineProperty,u=Object.defineProperties;var l=Object.getOwnPropertyDescriptors;var i=Object.getOwnPropertySymbols;var s=Object.prototype.hasOwnProperty,p=Object.prototype.propertyIsEnumerable;var r=(e,t,n)=>t in e?c(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,a=(e,t)=>{for(var n in t||(t={}))s.call(t,n)&&r(e,n,t[n]);if(i)for(var n of i(t))p.call(t,n)&&r(e,n,t[n]);return e},h=(e,t)=>u(e,l(t));var d=(e,t)=>{var n={};for(var o in e)s.call(e,o)&&t.indexOf(o)<0&&(n[o]=e[o]);if(e!=null&&i)for(var o of i(e))t.indexOf(o)<0&&p.call(e,o)&&(n[o]=e[o]);return n};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(n){var o=n,{components:e}=o,t=d(o,[\"components\"]);return mdx(MDXLayout,h(a(a({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"h2\",null,\"Step In\"),mdx(\"p\",null,`When stepping through code in the debugger, you can only step through\nfunctions that you have explicitly instrumented beforehand.`),mdx(\"p\",null,`This is still, by far, the biggest reason that I have to attach\nIntellij and debug from there.`),mdx(\"p\",null,`I'm not sure what the interface should be - hopefully something better\nthan what edebug does, which is a bit awkward.`),mdx(\"h2\",null,\"Eval\"),mdx(\"p\",null,\"While stopped in the debugger, you can press \",mdx(\"inlineCode\",{parentName:\"p\"},\"e\"),\" for \",mdx(\"inlineCode\",{parentName:\"p\"},\"eval\"),` (although\nit's not documented), but the resulting value is shown in an overlay,\nas if it was the value of the last expression.`),mdx(\"p\",null,\"You can work around this by evaluating \",mdx(\"inlineCode\",{parentName:\"p\"},\"(prn thing)\"),\" or \",mdx(\"inlineCode\",{parentName:\"p\"},`(pprint\nthing)`),\", but it might be nice to have an \",mdx(\"inlineCode\",{parentName:\"p\"},\"eval-and-pprint\"),\" command.\"),mdx(\"h2\",null,\"Overlays\"),mdx(\"p\",null,`Overlays are used to show values. (TODO: rant about overlays). I would\noften rather have the values pretty-printed into a dedicated buffer,\nso that I can search, copy, yank, etc.`),mdx(\"h2\",null,\"Conditional Breakpoints\"),mdx(\"p\",null,\"I want conditional breakpoints!\"),mdx(\"p\",null,\"Strawman:\"),mdx(\"pre\",a({},{className:\"language-clojure\"}),mdx(\"code\",a({parentName:\"pre\"},{className:\"language-clojure\"}),\"#break ^\",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token operator\"}),\":bp\"),\"/condition \",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token keyword\"}),\"some\"),\" expression\",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),\" \",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"foo bar \",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"baz\",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),`\n`)),mdx(\"p\",null,`I'm pretty sure that a reader literal only gets to operate on the\nsingle form that follows it, but I think attaching the condition as\nread-time metadata to the form would work.`),mdx(\"p\",null,\"Could also add a condition when instumenting a defn, perhaps with \",mdx(\"inlineCode\",{parentName:\"p\"},`C-u\nC-u C-M-x`),`, then prompting for a the condition expression, which would\nbe an expression of the arguments.`),mdx(\"h2\",null,\"Breakpoints List\"),mdx(\"p\",null,`You can show a list of instumented functions, but it's very\nspartan. Should be able to jump to the function, uninstrument, etc.`),mdx(\"p\",null,`It would also be nice to integrate this with the cider namespace\nbrowser (which itself could use some vast improvements!).`),mdx(\"h2\",null,\"Stacktrace\"),mdx(\"p\",null,\"There is now an \",mdx(\"inlineCode\",{parentName:\"p\"},\"s\"),\" command to show the current stacktrace. Yay!\"),mdx(\"p\",null,`It might be nice to highlight stack-frames that are instrumented, and\nto instrument or uninstrument functions directly from the stacktrace\nbuffer.`),mdx(\"p\",null,`The reason for this is that sometimes I am debugging and can see that\nthe parameters passed to the instrumented function are not what I\nexpected. I will want to re-run whatever I'm doing with some functions\nhigher in the stack instrumented so I can figure out where things went\nwrong.`),mdx(\"h2\",null,\"Inspector\"),mdx(\"p\",null,`The cider inspector is used to show locals while stopped in the\ndebugger.`),mdx(\"p\",null,`Expanding maps is tedious. It should expand maps and sequeneces\ninline, indented. More of a tree-like view.`),mdx(\"p\",null,`I also want it to live-update as I step, and retain its\nexpansion-state whenever possible.`),mdx(\"h2\",null,\"Break on Exceptions\"),mdx(\"p\",null,`Another thing that I currently turn to Intellij for is \"Break on\nException\". I would love it if cider could do this.`),mdx(\"p\",null,`I'm not quite sure how cider could implement this, given its approach\nof intrumenting functions one-at-a-time. `),mdx(\"p\",null,`One option is to have an option for mass-instrumenation of functions,\nby walking through loaded namespaces. This could be combined with an\noption to instrument code in such a way that it stops in the debugger\nat the point where an exception is thrown. As in Intellij, you would\nprobably want to break conditionally, based on the specific exception\nclass.`),mdx(\"p\",null,`Another, perhaps more ambitious option would be to also integrate an\nentirely different debugger, based on JPDA. There may some code to be\nscavenged from the old emacs clojure debugger project, which I can't\nquite remember the name of right now (Hugo Duncan made it).`),mdx(\"h2\",null,\"Thread\"),mdx(\"p\",null,\"I want multithreaded debugging.\"),mdx(\"p\",null,`Imagine being able to step through two functions, executing in\nparallel, in side-by-side emacs windows. You could play with various\nways of manually interleaving execution orders to reveal threading\nbugs (yes, those do happen in clojure!), race conditions, etc.`),mdx(\"p\",null,`At the moment, I don't think this works well, if at all, although I\nneed to do some experiments to see how far off we are. There certainly\nappear to be some bookkeeping vars in cider-nrepl's debug namespace\nthat are not multithread-aware.`),mdx(\"h2\",null,\"Macroexpansion\"),mdx(\"p\",null,`It would be pretty cool to step through the macroexpanded version of a\npiece of code, expanded inline.`),mdx(\"h2\",null,\"Finding Your Place\"),mdx(\"p\",null,\"At the moment, it's easy to lose your debug session.\"),mdx(\"p\",null,`Sometimes while stopped at a breakpoint, I start meta-dotting my way\naround the code, reading some other functions, etc. Eventually, I want\nto continue my debugging session, but I can't remember which function\nor even which namespace the debugger is stopped in. I need a way to\njump back to the code that I'm currently stopped in.`),mdx(\"h2\",null,\"Read Only\"),mdx(\"p\",null,`I would prefer if files were always read-only while debugging. The\nfact that you can type any character you like except for `,mdx(\"inlineCode\",{parentName:\"p\"},\"n\"),\", \",mdx(\"inlineCode\",{parentName:\"p\"},\"e\"),`,\netc. (the debugger commands) is just weird.`),mdx(\"p\",null,\"Also, if I'm pounding on \",mdx(\"inlineCode\",{parentName:\"p\"},\"n\"),` in rapid succession and hit a function\nthat takes some time (eg: a database call), then I accidentally start\ntyping n's into the code.`))}MDXContent.isMDXComponent=!0;\n"}}},"__N_SSG":true}