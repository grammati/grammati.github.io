{"pageProps":{"post":{"title":"Cider Debug Wishlist","slug":"blog/2016-02-02-cider-debug-wishlist","published":true,"datePublished":"2016-02-02T00:00:00.000Z","mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    code: \"code\",\n    pre: \"pre\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"Step In\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"When stepping through code in the debugger, you can only step through\\nfunctions that you have explicitly instrumented beforehand.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This is still, by far, the biggest reason that I have to attach\\nIntellij and debug from there.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I'm not sure what the interface should be - hopefully something better\\nthan what edebug does, which is a bit awkward.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Eval\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"While stopped in the debugger, you can press \", _jsx(_components.code, {\n        children: \"e\"\n      }), \" for \", _jsx(_components.code, {\n        children: \"eval\"\n      }), \" (although\\nit's not documented), but the resulting value is shown in an overlay,\\nas if it was the value of the last expression.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"You can work around this by evaluating \", _jsx(_components.code, {\n        children: \"(prn thing)\"\n      }), \" or \", _jsx(_components.code, {\n        children: \"(pprint thing)\"\n      }), \", but it might be nice to have an \", _jsx(_components.code, {\n        children: \"eval-and-pprint\"\n      }), \" command.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Overlays\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Overlays are used to show values. (TODO: rant about overlays). I would\\noften rather have the values pretty-printed into a dedicated buffer,\\nso that I can search, copy, yank, etc.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Conditional Breakpoints\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I want conditional breakpoints!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Strawman:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      className: \"language-clojure\",\n      children: _jsxs(_components.code, {\n        className: \"language-clojure\",\n        children: [\"#break ^\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"{\"\n        }), _jsx(_components.span, {\n          className: \"token operator\",\n          children: \":bp\"\n        }), \"/condition \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), _jsx(_components.span, {\n          className: \"token keyword\",\n          children: \"some\"\n        }), \" expression\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"}\"\n        }), \" \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), \"foo bar \", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \"(\"\n        }), \"baz\", _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), _jsx(_components.span, {\n          className: \"token punctuation\",\n          children: \")\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I'm pretty sure that a reader literal only gets to operate on the\\nsingle form that follows it, but I think attaching the condition as\\nread-time metadata to the form would work.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Could also add a condition when instumenting a defn, perhaps with \", _jsx(_components.code, {\n        children: \"C-u C-u C-M-x\"\n      }), \", then prompting for a the condition expression, which would\\nbe an expression of the arguments.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Breakpoints List\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"You can show a list of instumented functions, but it's very\\nspartan. Should be able to jump to the function, uninstrument, etc.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It would also be nice to integrate this with the cider namespace\\nbrowser (which itself could use some vast improvements!).\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Stacktrace\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"There is now an \", _jsx(_components.code, {\n        children: \"s\"\n      }), \" command to show the current stacktrace. Yay!\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It might be nice to highlight stack-frames that are instrumented, and\\nto instrument or uninstrument functions directly from the stacktrace\\nbuffer.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The reason for this is that sometimes I am debugging and can see that\\nthe parameters passed to the instrumented function are not what I\\nexpected. I will want to re-run whatever I'm doing with some functions\\nhigher in the stack instrumented so I can figure out where things went\\nwrong.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Inspector\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The cider inspector is used to show locals while stopped in the\\ndebugger.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Expanding maps is tedious. It should expand maps and sequeneces\\ninline, indented. More of a tree-like view.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I also want it to live-update as I step, and retain its\\nexpansion-state whenever possible.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Break on Exceptions\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Another thing that I currently turn to Intellij for is \\\"Break on\\nException\\\". I would love it if cider could do this.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I'm not quite sure how cider could implement this, given its approach\\nof intrumenting functions one-at-a-time.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"One option is to have an option for mass-instrumenation of functions,\\nby walking through loaded namespaces. This could be combined with an\\noption to instrument code in such a way that it stops in the debugger\\nat the point where an exception is thrown. As in Intellij, you would\\nprobably want to break conditionally, based on the specific exception\\nclass.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Another, perhaps more ambitious option would be to also integrate an\\nentirely different debugger, based on JPDA. There may some code to be\\nscavenged from the old emacs clojure debugger project, which I can't\\nquite remember the name of right now (Hugo Duncan made it).\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Thread\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"I want multithreaded debugging.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Imagine being able to step through two functions, executing in\\nparallel, in side-by-side emacs windows. You could play with various\\nways of manually interleaving execution orders to reveal threading\\nbugs (yes, those do happen in clojure!), race conditions, etc.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"At the moment, I don't think this works well, if at all, although I\\nneed to do some experiments to see how far off we are. There certainly\\nappear to be some bookkeeping vars in cider-nrepl's debug namespace\\nthat are not multithread-aware.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Macroexpansion\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It would be pretty cool to step through the macroexpanded version of a\\npiece of code, expanded inline.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Finding Your Place\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"At the moment, it's easy to lose your debug session.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Sometimes while stopped at a breakpoint, I start meta-dotting my way\\naround the code, reading some other functions, etc. Eventually, I want\\nto continue my debugging session, but I can't remember which function\\nor even which namespace the debugger is stopped in. I need a way to\\njump back to the code that I'm currently stopped in.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Read Only\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"I would prefer if files were always read-only while debugging. The\\nfact that you can type any character you like except for \", _jsx(_components.code, {\n        children: \"n\"\n      }), \", \", _jsx(_components.code, {\n        children: \"e\"\n      }), \",\\netc. (the debugger commands) is just weird.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Also, if I'm pounding on \", _jsx(_components.code, {\n        children: \"n\"\n      }), \" in rapid succession and hit a function\\nthat takes some time (eg: a database call), then I accidentally start\\ntyping n's into the code.\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}}},"__N_SSG":true}