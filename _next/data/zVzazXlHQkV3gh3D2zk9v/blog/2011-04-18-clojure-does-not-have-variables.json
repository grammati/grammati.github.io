{"pageProps":{"post":{"title":"Clojure Does Not Have Variables","slug":"blog/2011-04-18-clojure-does-not-have-variables","published":true,"datePublished":"2011-04-18T00:00:00.000Z","mdx":{"compiledSource":"var u=Object.defineProperty,y=Object.defineProperties;var l=Object.getOwnPropertyDescriptors;var n=Object.getOwnPropertySymbols;var a=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable;var i=(r,e,t)=>e in r?u(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,b=(r,e)=>{for(var t in e||(e={}))a.call(e,t)&&i(r,t,e[t]);if(n)for(var t of n(e))s.call(e,t)&&i(r,t,e[t]);return r},h=(r,e)=>y(r,l(e));var p=(r,e)=>{var t={};for(var o in r)a.call(r,o)&&e.indexOf(o)<0&&(t[o]=r[o]);if(r!=null&&n)for(var o of n(r))e.indexOf(o)<0&&s.call(r,o)&&(t[o]=r[o]);return t};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(t){var o=t,{components:r}=o,e=p(o,[\"components\"]);return mdx(MDXLayout,h(b(b({},layoutProps),e),{components:r,mdxType:\"MDXLayout\"}),mdx(\"p\",null,'Clojure, like many functional languages, does not have \"variables\".',\"\\xA0\",' It has \"bindings\", but they cannot vary - there is no concept of reassignment.',\"\\xA0\",\" But what does that really mean?\",mdx(\"br\",null),mdx(\"br\",null),\"When you see code like this:\",mdx(\"br\",null),mdx(\"br\",null),mdx(\"pre\",null,\"(let \",\"[x (something)\",mdx(\"br\",null),\"      y (blah x)\",mdx(\"br\",null),\"      x (more (stuff x) y)]\",mdx(\"br\",null),\"  (whatever x))\",mdx(\"br\",null)),mdx(\"br\",null),`you may very well think \"you are re-binding x - that's the same thing as a variable, for all intents and purposes\". And I agree that it looks that way. But it's not.`,mdx(\"br\",null),mdx(\"br\",null),\"Here's the difference:\",mdx(\"br\",null),mdx(\"br\",null),mdx(\"pre\",null,\"# python\",mdx(\"br\",null),\"def foo():\",mdx(\"br\",null),\"    x = 23\",mdx(\"br\",null),\"    y = lambda: x\",mdx(\"br\",null),\"    x = 44\",mdx(\"br\",null),\"    return y\",mdx(\"br\",null),mdx(\"br\",null),\"print foo()()\",mdx(\"br\",null)),mdx(\"br\",null),mdx(\"pre\",null,\"# ruby\",mdx(\"br\",null),\"def foo():\",mdx(\"br\",null),\"    x = 23\",mdx(\"br\",null),\"    y = lambda { x }\",mdx(\"br\",null),\"    x = 44\",mdx(\"br\",null),\"    y\",mdx(\"br\",null),mdx(\"br\",null),\"puts foo.call\",mdx(\"br\",null)),mdx(\"br\",null),mdx(\"pre\",null,\"// javascript\",mdx(\"br\",null),\"var foo = function(){\",mdx(\"br\",null),\"    var x = 23;\",mdx(\"br\",null),\"    var y = function(){ return x; }\",mdx(\"br\",null),\"    x = 44;\",mdx(\"br\",null),\"    return y;\",mdx(\"br\",null),\"};\",mdx(\"br\",null),\"alert( foo()() );\",mdx(\"br\",null)),mdx(\"br\",null),mdx(\"pre\",null,\"; clojure\",mdx(\"br\",null),\"(defn foo []\",mdx(\"br\",null),\"  (let [x 23\",mdx(\"br\",null),\"        y (fn [] x)\",mdx(\"br\",null),\"        x 44]\",mdx(\"br\",null),\"    y))\",mdx(\"br\",null),mdx(\"br\",null),\"(println ((foo)))\",mdx(\"br\",null)),mdx(\"br\",null),\"One of these things is not like the others... one of these things is not the same. (I can't remember which childhood TV show that's from).\",mdx(\"br\",null),mdx(\"br\",null),\"Three of the snippets above print 44. The other prints 23. That may not seem very significant, but it is. Immutability runs deeper than just unmodifiable vectors and maps.\"))}MDXContent.isMDXComponent=!0;\n"}}},"__N_SSG":true}