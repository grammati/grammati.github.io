<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Clojure Does Not Have Variables</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/1c4994f1e1f40687.css" as="style"/><link rel="stylesheet" href="/_next/static/css/1c4994f1e1f40687.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-fd1bc4a65a80e5c8.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-83803dd478f5b5bc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-8e724d512a48494e.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bblog%5D-c7bcc8d294737d5d.js" defer=""></script><script src="/_next/static/cqXpSDqY94nqmGVpYcMQ-/_buildManifest.js" defer=""></script><script src="/_next/static/cqXpSDqY94nqmGVpYcMQ-/_ssgManifest.js" defer=""></script><script src="/_next/static/cqXpSDqY94nqmGVpYcMQ-/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="container"><link href="//fonts.googleapis.com/css?family=Limelight|Inter" rel="stylesheet" type="text/css"/><div class="header"><header role="banner"><hgroup><h1><a href="/">pro.grammati.ca</a></h1></hgroup></header><nav role="navigation"><ul class="main-navigation"><li><a href="/blog">Blog</a></li><li><a href="/library">Library</a></li><li><a href="/about">About</a></li></ul></nav></div><div class="blog-post"><div class="blog-post-title"><h1>Clojure Does Not Have Variables</h1><br/></div><div class="blog-post-content"><p>Clojure, like many functional languages, does not have &quot;variables&quot;.<!-- --> <!-- --> It has &quot;bindings&quot;, but they cannot vary - there is no concept of reassignment.<!-- --> <!-- --> But what does that really mean?<br/><br/>When you see code like this:<br/><br/><pre>(let <!-- -->[x (something)<br/>      y (blah x)<br/>      x (more (stuff x) y)]<br/>  (whatever x))<br/></pre><br/>you may very well think &quot;you are re-binding x - that&#x27;s the same thing as a variable, for all intents and purposes&quot;. And I agree that it looks that way. But it&#x27;s not.<br/><br/>Here&#x27;s the difference:<br/><br/><pre># python<br/>def foo():<br/>    x = 23<br/>    y = lambda: x<br/>    x = 44<br/>    return y<br/><br/>print foo()()<br/></pre><br/><pre># ruby<br/>def foo():<br/>    x = 23<br/>    y = lambda { x }<br/>    x = 44<br/>    y<br/><br/>puts foo.call<br/></pre><br/><pre>// javascript<br/>var foo = function(){<br/>    var x = 23;<br/>    var y = function(){ return x; }<br/>    x = 44;<br/>    return y;<br/>};<br/>alert( foo()() );<br/></pre><br/><pre>; clojure<br/>(defn foo []<br/>  (let [x 23<br/>        y (fn [] x)<br/>        x 44]<br/>    y))<br/><br/>(println ((foo)))<br/></pre><br/>One of these things is not like the others... one of these things is not the same. (I can&#x27;t remember which childhood TV show that&#x27;s from).<br/><br/>Three of the snippets above print 44. The other prints 23. That may not seem very significant, but it is. Immutability runs deeper than just unmodifiable vectors and maps.</p></div></div><footer class="footer"><p>© Chris Perkins 2022</p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Clojure Does Not Have Variables","slug":"blog/2011-04-18-clojure-does-not-have-variables","published":true,"datePublished":"2011-04-18T00:00:00.000Z","mdx":{"compiledSource":"var u=Object.defineProperty,y=Object.defineProperties;var l=Object.getOwnPropertyDescriptors;var n=Object.getOwnPropertySymbols;var a=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable;var i=(r,e,t)=\u003ee in r?u(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,b=(r,e)=\u003e{for(var t in e||(e={}))a.call(e,t)\u0026\u0026i(r,t,e[t]);if(n)for(var t of n(e))s.call(e,t)\u0026\u0026i(r,t,e[t]);return r},h=(r,e)=\u003ey(r,l(e));var p=(r,e)=\u003e{var t={};for(var o in r)a.call(r,o)\u0026\u0026e.indexOf(o)\u003c0\u0026\u0026(t[o]=r[o]);if(r!=null\u0026\u0026n)for(var o of n(r))e.indexOf(o)\u003c0\u0026\u0026s.call(r,o)\u0026\u0026(t[o]=r[o]);return t};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(t){var o=t,{components:r}=o,e=p(o,[\"components\"]);return mdx(MDXLayout,h(b(b({},layoutProps),e),{components:r,mdxType:\"MDXLayout\"}),mdx(\"p\",null,'Clojure, like many functional languages, does not have \"variables\".',\"\\xA0\",' It has \"bindings\", but they cannot vary - there is no concept of reassignment.',\"\\xA0\",\" But what does that really mean?\",mdx(\"br\",null),mdx(\"br\",null),\"When you see code like this:\",mdx(\"br\",null),mdx(\"br\",null),mdx(\"pre\",null,\"(let \",\"[x (something)\",mdx(\"br\",null),\"      y (blah x)\",mdx(\"br\",null),\"      x (more (stuff x) y)]\",mdx(\"br\",null),\"  (whatever x))\",mdx(\"br\",null)),mdx(\"br\",null),`you may very well think \"you are re-binding x - that's the same thing as a variable, for all intents and purposes\". And I agree that it looks that way. But it's not.`,mdx(\"br\",null),mdx(\"br\",null),\"Here's the difference:\",mdx(\"br\",null),mdx(\"br\",null),mdx(\"pre\",null,\"# python\",mdx(\"br\",null),\"def foo():\",mdx(\"br\",null),\"    x = 23\",mdx(\"br\",null),\"    y = lambda: x\",mdx(\"br\",null),\"    x = 44\",mdx(\"br\",null),\"    return y\",mdx(\"br\",null),mdx(\"br\",null),\"print foo()()\",mdx(\"br\",null)),mdx(\"br\",null),mdx(\"pre\",null,\"# ruby\",mdx(\"br\",null),\"def foo():\",mdx(\"br\",null),\"    x = 23\",mdx(\"br\",null),\"    y = lambda { x }\",mdx(\"br\",null),\"    x = 44\",mdx(\"br\",null),\"    y\",mdx(\"br\",null),mdx(\"br\",null),\"puts foo.call\",mdx(\"br\",null)),mdx(\"br\",null),mdx(\"pre\",null,\"// javascript\",mdx(\"br\",null),\"var foo = function(){\",mdx(\"br\",null),\"    var x = 23;\",mdx(\"br\",null),\"    var y = function(){ return x; }\",mdx(\"br\",null),\"    x = 44;\",mdx(\"br\",null),\"    return y;\",mdx(\"br\",null),\"};\",mdx(\"br\",null),\"alert( foo()() );\",mdx(\"br\",null)),mdx(\"br\",null),mdx(\"pre\",null,\"; clojure\",mdx(\"br\",null),\"(defn foo []\",mdx(\"br\",null),\"  (let [x 23\",mdx(\"br\",null),\"        y (fn [] x)\",mdx(\"br\",null),\"        x 44]\",mdx(\"br\",null),\"    y))\",mdx(\"br\",null),mdx(\"br\",null),\"(println ((foo)))\",mdx(\"br\",null)),mdx(\"br\",null),\"One of these things is not like the others... one of these things is not the same. (I can't remember which childhood TV show that's from).\",mdx(\"br\",null),mdx(\"br\",null),\"Three of the snippets above print 44. The other prints 23. That may not seem very significant, but it is. Immutability runs deeper than just unmodifiable vectors and maps.\"))}MDXContent.isMDXComponent=!0;\n"}}},"__N_SSG":true},"page":"/blog/[blog]","query":{"blog":"2011-04-18-clojure-does-not-have-variables"},"buildId":"cqXpSDqY94nqmGVpYcMQ-","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>