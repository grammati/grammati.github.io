<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Cider Debug Wishlist</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/1c4994f1e1f40687.css" as="style"/><link rel="stylesheet" href="/_next/static/css/1c4994f1e1f40687.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-fd1bc4a65a80e5c8.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-83803dd478f5b5bc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-8e724d512a48494e.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bblog%5D-c7bcc8d294737d5d.js" defer=""></script><script src="/_next/static/cqXpSDqY94nqmGVpYcMQ-/_buildManifest.js" defer=""></script><script src="/_next/static/cqXpSDqY94nqmGVpYcMQ-/_ssgManifest.js" defer=""></script><script src="/_next/static/cqXpSDqY94nqmGVpYcMQ-/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="container"><link href="//fonts.googleapis.com/css?family=Limelight|Inter" rel="stylesheet" type="text/css"/><div class="header"><header role="banner"><hgroup><h1><a href="/">pro.grammati.ca</a></h1></hgroup></header><nav role="navigation"><ul class="main-navigation"><li><a href="/blog">Blog</a></li><li><a href="/library">Library</a></li><li><a href="/about">About</a></li></ul></nav></div><div class="blog-post"><div class="blog-post-title"><h1>Cider Debug Wishlist</h1><br/></div><div class="blog-post-content"><h2>Step In</h2><p>When stepping through code in the debugger, you can only step through
functions that you have explicitly instrumented beforehand.</p><p>This is still, by far, the biggest reason that I have to attach
Intellij and debug from there.</p><p>I&#x27;m not sure what the interface should be - hopefully something better
than what edebug does, which is a bit awkward.</p><h2>Eval</h2><p>While stopped in the debugger, you can press <code>e</code> for <code>eval</code> (although
it&#x27;s not documented), but the resulting value is shown in an overlay,
as if it was the value of the last expression.</p><p>You can work around this by evaluating <code>(prn thing)</code> or <code>(pprint
thing)</code>, but it might be nice to have an <code>eval-and-pprint</code> command.</p><h2>Overlays</h2><p>Overlays are used to show values. (TODO: rant about overlays). I would
often rather have the values pretty-printed into a dedicated buffer,
so that I can search, copy, yank, etc.</p><h2>Conditional Breakpoints</h2><p>I want conditional breakpoints!</p><p>Strawman:</p><pre class="language-clojure"><code class="language-clojure">#break ^<span class="token punctuation">{</span><span class="token operator">:bp</span>/condition <span class="token punctuation">(</span><span class="token keyword">some</span> expression<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token punctuation">(</span>foo bar <span class="token punctuation">(</span>baz<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><p>I&#x27;m pretty sure that a reader literal only gets to operate on the
single form that follows it, but I think attaching the condition as
read-time metadata to the form would work.</p><p>Could also add a condition when instumenting a defn, perhaps with <code>C-u
C-u C-M-x</code>, then prompting for a the condition expression, which would
be an expression of the arguments.</p><h2>Breakpoints List</h2><p>You can show a list of instumented functions, but it&#x27;s very
spartan. Should be able to jump to the function, uninstrument, etc.</p><p>It would also be nice to integrate this with the cider namespace
browser (which itself could use some vast improvements!).</p><h2>Stacktrace</h2><p>There is now an <code>s</code> command to show the current stacktrace. Yay!</p><p>It might be nice to highlight stack-frames that are instrumented, and
to instrument or uninstrument functions directly from the stacktrace
buffer.</p><p>The reason for this is that sometimes I am debugging and can see that
the parameters passed to the instrumented function are not what I
expected. I will want to re-run whatever I&#x27;m doing with some functions
higher in the stack instrumented so I can figure out where things went
wrong.</p><h2>Inspector</h2><p>The cider inspector is used to show locals while stopped in the
debugger.</p><p>Expanding maps is tedious. It should expand maps and sequeneces
inline, indented. More of a tree-like view.</p><p>I also want it to live-update as I step, and retain its
expansion-state whenever possible.</p><h2>Break on Exceptions</h2><p>Another thing that I currently turn to Intellij for is &quot;Break on
Exception&quot;. I would love it if cider could do this.</p><p>I&#x27;m not quite sure how cider could implement this, given its approach
of intrumenting functions one-at-a-time. </p><p>One option is to have an option for mass-instrumenation of functions,
by walking through loaded namespaces. This could be combined with an
option to instrument code in such a way that it stops in the debugger
at the point where an exception is thrown. As in Intellij, you would
probably want to break conditionally, based on the specific exception
class.</p><p>Another, perhaps more ambitious option would be to also integrate an
entirely different debugger, based on JPDA. There may some code to be
scavenged from the old emacs clojure debugger project, which I can&#x27;t
quite remember the name of right now (Hugo Duncan made it).</p><h2>Thread</h2><p>I want multithreaded debugging.</p><p>Imagine being able to step through two functions, executing in
parallel, in side-by-side emacs windows. You could play with various
ways of manually interleaving execution orders to reveal threading
bugs (yes, those do happen in clojure!), race conditions, etc.</p><p>At the moment, I don&#x27;t think this works well, if at all, although I
need to do some experiments to see how far off we are. There certainly
appear to be some bookkeeping vars in cider-nrepl&#x27;s debug namespace
that are not multithread-aware.</p><h2>Macroexpansion</h2><p>It would be pretty cool to step through the macroexpanded version of a
piece of code, expanded inline.</p><h2>Finding Your Place</h2><p>At the moment, it&#x27;s easy to lose your debug session.</p><p>Sometimes while stopped at a breakpoint, I start meta-dotting my way
around the code, reading some other functions, etc. Eventually, I want
to continue my debugging session, but I can&#x27;t remember which function
or even which namespace the debugger is stopped in. I need a way to
jump back to the code that I&#x27;m currently stopped in.</p><h2>Read Only</h2><p>I would prefer if files were always read-only while debugging. The
fact that you can type any character you like except for <code>n</code>, <code>e</code>,
etc. (the debugger commands) is just weird.</p><p>Also, if I&#x27;m pounding on <code>n</code> in rapid succession and hit a function
that takes some time (eg: a database call), then I accidentally start
typing n&#x27;s into the code.</p></div></div><footer class="footer"><p>Â© Chris Perkins 2022</p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Cider Debug Wishlist","slug":"blog/2016-02-02-cider-debug-wishlist","published":true,"datePublished":"2016-02-02T00:00:00.000Z","mdx":{"compiledSource":"var c=Object.defineProperty,u=Object.defineProperties;var l=Object.getOwnPropertyDescriptors;var i=Object.getOwnPropertySymbols;var s=Object.prototype.hasOwnProperty,p=Object.prototype.propertyIsEnumerable;var r=(e,t,n)=\u003et in e?c(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,a=(e,t)=\u003e{for(var n in t||(t={}))s.call(t,n)\u0026\u0026r(e,n,t[n]);if(i)for(var n of i(t))p.call(t,n)\u0026\u0026r(e,n,t[n]);return e},h=(e,t)=\u003eu(e,l(t));var d=(e,t)=\u003e{var n={};for(var o in e)s.call(e,o)\u0026\u0026t.indexOf(o)\u003c0\u0026\u0026(n[o]=e[o]);if(e!=null\u0026\u0026i)for(var o of i(e))t.indexOf(o)\u003c0\u0026\u0026p.call(e,o)\u0026\u0026(n[o]=e[o]);return n};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(n){var o=n,{components:e}=o,t=d(o,[\"components\"]);return mdx(MDXLayout,h(a(a({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"h2\",null,\"Step In\"),mdx(\"p\",null,`When stepping through code in the debugger, you can only step through\nfunctions that you have explicitly instrumented beforehand.`),mdx(\"p\",null,`This is still, by far, the biggest reason that I have to attach\nIntellij and debug from there.`),mdx(\"p\",null,`I'm not sure what the interface should be - hopefully something better\nthan what edebug does, which is a bit awkward.`),mdx(\"h2\",null,\"Eval\"),mdx(\"p\",null,\"While stopped in the debugger, you can press \",mdx(\"inlineCode\",{parentName:\"p\"},\"e\"),\" for \",mdx(\"inlineCode\",{parentName:\"p\"},\"eval\"),` (although\nit's not documented), but the resulting value is shown in an overlay,\nas if it was the value of the last expression.`),mdx(\"p\",null,\"You can work around this by evaluating \",mdx(\"inlineCode\",{parentName:\"p\"},\"(prn thing)\"),\" or \",mdx(\"inlineCode\",{parentName:\"p\"},`(pprint\nthing)`),\", but it might be nice to have an \",mdx(\"inlineCode\",{parentName:\"p\"},\"eval-and-pprint\"),\" command.\"),mdx(\"h2\",null,\"Overlays\"),mdx(\"p\",null,`Overlays are used to show values. (TODO: rant about overlays). I would\noften rather have the values pretty-printed into a dedicated buffer,\nso that I can search, copy, yank, etc.`),mdx(\"h2\",null,\"Conditional Breakpoints\"),mdx(\"p\",null,\"I want conditional breakpoints!\"),mdx(\"p\",null,\"Strawman:\"),mdx(\"pre\",a({},{className:\"language-clojure\"}),mdx(\"code\",a({parentName:\"pre\"},{className:\"language-clojure\"}),\"#break ^\",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"{\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token operator\"}),\":bp\"),\"/condition \",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token keyword\"}),\"some\"),\" expression\",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"}\"),\" \",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"foo bar \",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\"(\"),\"baz\",mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),mdx(\"span\",a({parentName:\"code\"},{className:\"token punctuation\"}),\")\"),`\n`)),mdx(\"p\",null,`I'm pretty sure that a reader literal only gets to operate on the\nsingle form that follows it, but I think attaching the condition as\nread-time metadata to the form would work.`),mdx(\"p\",null,\"Could also add a condition when instumenting a defn, perhaps with \",mdx(\"inlineCode\",{parentName:\"p\"},`C-u\nC-u C-M-x`),`, then prompting for a the condition expression, which would\nbe an expression of the arguments.`),mdx(\"h2\",null,\"Breakpoints List\"),mdx(\"p\",null,`You can show a list of instumented functions, but it's very\nspartan. Should be able to jump to the function, uninstrument, etc.`),mdx(\"p\",null,`It would also be nice to integrate this with the cider namespace\nbrowser (which itself could use some vast improvements!).`),mdx(\"h2\",null,\"Stacktrace\"),mdx(\"p\",null,\"There is now an \",mdx(\"inlineCode\",{parentName:\"p\"},\"s\"),\" command to show the current stacktrace. Yay!\"),mdx(\"p\",null,`It might be nice to highlight stack-frames that are instrumented, and\nto instrument or uninstrument functions directly from the stacktrace\nbuffer.`),mdx(\"p\",null,`The reason for this is that sometimes I am debugging and can see that\nthe parameters passed to the instrumented function are not what I\nexpected. I will want to re-run whatever I'm doing with some functions\nhigher in the stack instrumented so I can figure out where things went\nwrong.`),mdx(\"h2\",null,\"Inspector\"),mdx(\"p\",null,`The cider inspector is used to show locals while stopped in the\ndebugger.`),mdx(\"p\",null,`Expanding maps is tedious. It should expand maps and sequeneces\ninline, indented. More of a tree-like view.`),mdx(\"p\",null,`I also want it to live-update as I step, and retain its\nexpansion-state whenever possible.`),mdx(\"h2\",null,\"Break on Exceptions\"),mdx(\"p\",null,`Another thing that I currently turn to Intellij for is \"Break on\nException\". I would love it if cider could do this.`),mdx(\"p\",null,`I'm not quite sure how cider could implement this, given its approach\nof intrumenting functions one-at-a-time. `),mdx(\"p\",null,`One option is to have an option for mass-instrumenation of functions,\nby walking through loaded namespaces. This could be combined with an\noption to instrument code in such a way that it stops in the debugger\nat the point where an exception is thrown. As in Intellij, you would\nprobably want to break conditionally, based on the specific exception\nclass.`),mdx(\"p\",null,`Another, perhaps more ambitious option would be to also integrate an\nentirely different debugger, based on JPDA. There may some code to be\nscavenged from the old emacs clojure debugger project, which I can't\nquite remember the name of right now (Hugo Duncan made it).`),mdx(\"h2\",null,\"Thread\"),mdx(\"p\",null,\"I want multithreaded debugging.\"),mdx(\"p\",null,`Imagine being able to step through two functions, executing in\nparallel, in side-by-side emacs windows. You could play with various\nways of manually interleaving execution orders to reveal threading\nbugs (yes, those do happen in clojure!), race conditions, etc.`),mdx(\"p\",null,`At the moment, I don't think this works well, if at all, although I\nneed to do some experiments to see how far off we are. There certainly\nappear to be some bookkeeping vars in cider-nrepl's debug namespace\nthat are not multithread-aware.`),mdx(\"h2\",null,\"Macroexpansion\"),mdx(\"p\",null,`It would be pretty cool to step through the macroexpanded version of a\npiece of code, expanded inline.`),mdx(\"h2\",null,\"Finding Your Place\"),mdx(\"p\",null,\"At the moment, it's easy to lose your debug session.\"),mdx(\"p\",null,`Sometimes while stopped at a breakpoint, I start meta-dotting my way\naround the code, reading some other functions, etc. Eventually, I want\nto continue my debugging session, but I can't remember which function\nor even which namespace the debugger is stopped in. I need a way to\njump back to the code that I'm currently stopped in.`),mdx(\"h2\",null,\"Read Only\"),mdx(\"p\",null,`I would prefer if files were always read-only while debugging. The\nfact that you can type any character you like except for `,mdx(\"inlineCode\",{parentName:\"p\"},\"n\"),\", \",mdx(\"inlineCode\",{parentName:\"p\"},\"e\"),`,\netc. (the debugger commands) is just weird.`),mdx(\"p\",null,\"Also, if I'm pounding on \",mdx(\"inlineCode\",{parentName:\"p\"},\"n\"),` in rapid succession and hit a function\nthat takes some time (eg: a database call), then I accidentally start\ntyping n's into the code.`))}MDXContent.isMDXComponent=!0;\n"}}},"__N_SSG":true},"page":"/blog/[blog]","query":{"blog":"2016-02-02-cider-debug-wishlist"},"buildId":"cqXpSDqY94nqmGVpYcMQ-","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>