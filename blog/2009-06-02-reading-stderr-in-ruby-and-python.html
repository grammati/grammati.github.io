<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Reading stderr in Ruby and Python</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/6252fe27697d5dc7.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6252fe27697d5dc7.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-fd82975a6094609f.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-83803dd478f5b5bc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-34f82ae4e15b35d6.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bblog%5D-c7bcc8d294737d5d.js" defer=""></script><script src="/_next/static/_zHY-aSTIfZjDo9Os7m5q/_buildManifest.js" defer=""></script><script src="/_next/static/_zHY-aSTIfZjDo9Os7m5q/_ssgManifest.js" defer=""></script><script src="/_next/static/_zHY-aSTIfZjDo9Os7m5q/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="container"><link href="//fonts.googleapis.com/css?family=Cardo|Limelight" rel="stylesheet" type="text/css"/><div class="header"><header role="banner"><hgroup><h1><a href="/">pro.grammati.ca</a></h1></hgroup></header><nav role="navigation"><ul class="main-navigation"><li><a href="/blog">Blog</a></li><li><a href="/library">Library</a></li><li><a href="/about">About</a></li></ul></nav></div><div class="blog-post"><div class="blog-post-title"><h1>Reading stderr in Ruby and Python</h1><br/></div><div class="blog-post-content"><p>When I learned Ruby, one of the things that immediately struck me was how much easier it is than Python for doing simple, shell-scripting, sys-admin-y type tasks.  I was in love with backticks - running a shell command just seemed soooo much easier than fiddling around with Python&#x27;s arcane subprocess module, which I never really liked. But I always had the slightly uneasy feeling that Ruby was probably just making the simple, 80% case easy. Today, that was confirmed.<br/><br/>The command I want to run today is <code>p4 opened</code>.  The problem is that if I am not logged in to Perforce, the command returns nothing in stdout, but prints an error message to stderr. I want to capture the message.  &quot;No problem,&quot; I thought.  &quot;I&#x27;m just hitting the 20% case for the first time.&quot;  So off I go to look up Kernel.open, and Kernel.system, and IO.popen, Open3.popen3, etc...<br/><br/>Let&#x27;s jump to the punchline: guess how you read the stderr of a subprocess in Ruby on Windows?  Drumroll...  You can&#x27;t!  No, really, I&#x27;m not kidding.  You actually cannot do it.  WTF?<br/><br/>So, back to trusty old Python:<br/><br/>from subprocess import Popen, PIPE<br/>p = subprocess.Popen(<!-- -->[&#x27;p4&#x27;, &#x27;opened&#x27;]<!-- -->, stdout=PIPE, stderr=PIPE)<br/>out= p.stdout.read()<br/>err = p.stderr.read()<br/><br/>Hmm, good old subprocess sure doesn&#x27;t look so ugly to me anymore. It may not have the cool-factor of backticks, but dammit, it works!  That counts for a hell of a lot.</p></div></div><footer class="footer"><p>Â© Chris Perkins 2022</p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Reading stderr in Ruby and Python","slug":"blog/2009-06-02-reading-stderr-in-ruby-and-python","datePublished":"2009-06-02T00:00:00.000Z","mdx":{"compiledSource":"var l=Object.defineProperty,p=Object.defineProperties;var m=Object.getOwnPropertyDescriptors;var s=Object.getOwnPropertySymbols;var a=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable;var u=(e,o,t)=\u003eo in e?l(e,o,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[o]=t,r=(e,o)=\u003e{for(var t in o||(o={}))a.call(o,t)\u0026\u0026u(e,t,o[t]);if(s)for(var t of s(o))i.call(o,t)\u0026\u0026u(e,t,o[t]);return e},d=(e,o)=\u003ep(e,m(o));var h=(e,o)=\u003e{var t={};for(var n in e)a.call(e,n)\u0026\u0026o.indexOf(n)\u003c0\u0026\u0026(t[n]=e[n]);if(e!=null\u0026\u0026s)for(var n of s(e))o.indexOf(n)\u003c0\u0026\u0026i.call(e,n)\u0026\u0026(t[n]=e[n]);return t};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(t){var n=t,{components:e}=n,o=h(n,[\"components\"]);return mdx(MDXLayout,d(r(r({},layoutProps),o),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"When I learned Ruby, one of the things that immediately struck me was how much easier it is than Python for doing simple, shell-scripting, sys-admin-y type tasks.  I was in love with backticks - running a shell command just seemed soooo much easier than fiddling around with Python's arcane subprocess module, which I never really liked. But I always had the slightly uneasy feeling that Ruby was probably just making the simple, 80% case easy. Today, that was confirmed.\",mdx(\"br\",null),mdx(\"br\",null),\"The command I want to run today is \",mdx(\"inlineCode\",{parentName:\"p\"},\"p4 opened\"),`.  The problem is that if I am not logged in to Perforce, the command returns nothing in stdout, but prints an error message to stderr. I want to capture the message.  \"No problem,\" I thought.  \"I'm just hitting the 20% case for the first time.\"  So off I go to look up Kernel.open, and Kernel.system, and IO.popen, Open3.popen3, etc...`,mdx(\"br\",null),mdx(\"br\",null),\"Let's jump to the punchline: guess how you read the stderr of a subprocess in Ruby on Windows?  Drumroll...  You can't!  No, really, I'm not kidding.  You actually cannot do it.  WTF?\",mdx(\"br\",null),mdx(\"br\",null),\"So, back to trusty old Python:\",mdx(\"br\",null),mdx(\"br\",null),\"from subprocess import Popen, PIPE\",mdx(\"br\",null),\"p = subprocess.Popen(\",\"['p4', 'opened']\",\", stdout=PIPE, stderr=PIPE)\",mdx(\"br\",null),\"out= p.stdout.read()\",mdx(\"br\",null),\"err = p.stderr.read()\",mdx(\"br\",null),mdx(\"br\",null),\"Hmm, good old subprocess sure doesn't look so ugly to me anymore. It may not have the cool-factor of backticks, but dammit, it works!  That counts for a hell of a lot.\"))}MDXContent.isMDXComponent=!0;\n"}}},"__N_SSG":true},"page":"/blog/[blog]","query":{"blog":"2009-06-02-reading-stderr-in-ruby-and-python"},"buildId":"_zHY-aSTIfZjDo9Os7m5q","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>