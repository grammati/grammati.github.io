<!DOCTYPE html>

<html><head><link href="http://pro.grammati.ca//blog/2009/06/10/clojure-day-2/index.html" rel="canonical" /><meta content="True" name="HandheldFriendly" /><meta content="320" name="MobileOptimized" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta charset="utf-8" /><title>pro.grammati.ca</title><link href="/css/32ca7f0b6575/theme.css" rel="stylesheet" /><link href="/css/d4de3943cb2d/zenburn-custom.css" rel="stylesheet" /><link href="http://fonts.googleapis.com/css?family=Cardo|Limelight" rel="stylesheet" type="text/css" /></head><body><header role="banner"><hgroup><h1><a href="/">pro.grammati.ca</a></h1></hgroup></header><nav role="navigation"><ul class="main-navigation"><li><a href="/blog/">Blog</a></li><li><a href="/atom.xml">Feed</a></li><li><a href="/about/">About</a></li></ul></nav><div id="main"><div id="content"><article class="entry" role="article"><header><h1 class="entry-title">Clojure, Day 2</h1><p class="meta"><time datetime="2009-06-10T00:00:00.000Z">2009-06-10</time></p></header><div class="body entry-content"><p>Holy crap dude, clojure going to be a problem for me! This is only my second day playing with it, and I think I'm getting hooked. I find myself giggling like an idiot as I type things into the REPL and then say "WTF? That actually worked?". I don't think I've had this much fun with a language since I learned Python almost a decade ago.</p><p>As a part of the task I set for myself, I wanted to do something like Python's str.rpartition, but for an arbitrary sequence. It should take a sequence and a predicate, and return a 3-tuple (ok, I still speak Python) of (left, item, right), where item is the last item matching the predicate, and left and right are sequences of the parts before and after it. For example:</p><pre><code class="codehilite"><span></span><span class="p">(</span><span class="nb">prn </span><span class="p">(</span><span class="nf">rpartition</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">]</span> <span class="o">#</span><span class="p">{</span><span class="mi">3</span> <span class="mi">4</span><span class="p">}))</span> <span class="nb">-&gt; </span><span class="p">[(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">4</span> <span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="p">(</span><span class="nb">prn </span><span class="p">(</span><span class="nf">rpartition</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">]</span> <span class="o">#</span><span class="p">{</span><span class="mi">4</span> <span class="mi">2</span><span class="p">}))</span> <span class="nb">-&gt; </span><span class="p">[(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">4</span> <span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="p">(</span><span class="nb">prn </span><span class="p">(</span><span class="nf">rpartition</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">]</span> <span class="o">#</span><span class="p">{</span><span class="mi">1</span><span class="p">}))</span> <span class="nb">-&gt; </span><span class="p">[()</span> <span class="mi">1</span> <span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)]</span>
<span class="p">(</span><span class="nb">prn </span><span class="p">(</span><span class="nf">rpartition</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">]</span> <span class="o">#</span><span class="p">{}))</span> <span class="nb">-&gt; </span><span class="p">[()</span> <span class="nv">nil</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)]</span>
</code></pre><p>At first I was trying to do things like finding the index of matching items - but I was vaguely uneasy about that, as it seemed rather non-functional. Then I tried a solution that assumed that (seq coll) returns a stateful iterator (it doesn't, but there may be another function that does - if so I don't know what it is yet). I finally zeroed in on something that works, in about 7 or 8 lines of code, and then I started to clean it up. It ended up like this:</p><pre><code class="codehilite"><span></span><span class="p">(</span><span class="kd">defn </span><span class="nv">rpartition</span> <span class="p">[</span><span class="nv">coll</span> <span class="nv">pred</span><span class="p">]</span>
  <span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nb">right </span><span class="p">[</span><span class="nv">split</span> <span class="o">&amp;</span><span class="nv">amp</span><span class="c1">; left]] (split-with (complement pred) (reverse coll))]</span>
    <span class="p">[(</span><span class="nb">reverse </span><span class="nv">left</span><span class="p">)</span> <span class="nv">split</span> <span class="p">(</span><span class="nb">reverse </span><span class="nv">right</span><span class="p">)]))</span>
</code></pre><p>Coolnesses to note:</p><ul><li>The nested "assignment" in the let. I tried the "&amp; left" part on a whim, and by god it worked! Way cool.</li><li>I assumed that giving an empty sequence to "[split &amp; left]" would be an error and that I would have to add handling for that edge case. In fact it gives me nil and () respectively. It just "does the right thing". Wicked cool.</li><li>Note in the examples that my predicates are just set literals. "Calling" a set is effectively a membership test. You can't get any simpler than that. Mega cool.</li><li>Next step: learn how to abuse macros, as a prerequisite to learning how to not abuse macros.</li></ul></div></article></div></div><footer role="contentinfo"><p>Copyright Â© 2020 - Chris Perkins</p></footer></body></html>