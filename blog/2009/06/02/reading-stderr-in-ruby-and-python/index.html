<!DOCTYPE html>

<html><head><link href="http://pro.grammati.ca//blog/2009/06/02/reading-stderr-in-ruby-and-python/index.html" rel="canonical" /><meta content="True" name="HandheldFriendly" /><meta content="320" name="MobileOptimized" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta charset="utf-8" /><title>pro.grammati.ca</title><link href="/css/32ca7f0b6575/theme.css" rel="stylesheet" /><link href="/css/d4de3943cb2d/zenburn-custom.css" rel="stylesheet" /><link href="http://fonts.googleapis.com/css?family=Cardo|Limelight" rel="stylesheet" type="text/css" /></head><body><header role="banner"><hgroup><h1><a href="/">pro.grammati.ca</a></h1></hgroup></header><nav role="navigation"><ul class="main-navigation"><li><a href="/blog/">Blog</a></li><li><a href="/atom.xml">Feed</a></li><li><a href="/about/">About</a></li></ul></nav><div id="main"><div id="content"><article class="entry" role="article"><header><h1 class="entry-title">Reading stderr in Ruby and Python</h1><p class="meta"><time datetime="2009-06-02T00:00:00.000Z">2009-06-02</time></p></header><div class="body entry-content"><p>When I learned Ruby, one of the things that immediately struck me was how much easier it is than Python for doing simple, shell-scripting, sys-admin-y type tasks.  I was in love with backticks - running a shell command just seemed soooo much easier than fiddling around with Python's arcane subprocess module, which I never really liked. But I always had the slightly uneasy feeling that Ruby was probably just making the simple, 80% case easy. Today, that was confirmed.<br /><br />The command I want to run today is <code>p4 opened</code>.  The problem is that if I am not logged in to Perforce, the command returns nothing in stdout, but prints an error message to stderr. I want to capture the message.  "No problem," I thought.  "I'm just hitting the 20% case for the first time."  So off I go to look up Kernel.open, and Kernel.system, and IO.popen, Open3.popen3, etc...<br /><br />Let's jump to the punchline: guess how you read the stderr of a subprocess in Ruby on Windows?  Drumroll...  You can't!  No, really, I'm not kidding.  You actually cannot do it.  WTF?<br /><br />So, back to trusty old Python:<br /><br />from subprocess import Popen, PIPE<br />p = subprocess.Popen(['p4', 'opened'], stdout=PIPE, stderr=PIPE)<br />out= p.stdout.read()<br />err = p.stderr.read()<br /><br />Hmm, good old subprocess sure doesn't look so ugly to me anymore. It may not have the cool-factor of backticks, but dammit, it works!  That counts for a hell of a lot.</p></div></article></div></div><footer role="contentinfo"><p>Copyright Â© 2020 - Chris Perkins</p></footer></body></html>