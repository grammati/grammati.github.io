<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Microbucks</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/6252fe27697d5dc7.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6252fe27697d5dc7.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-fd82975a6094609f.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-83803dd478f5b5bc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-34f82ae4e15b35d6.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bblog%5D-c7bcc8d294737d5d.js" defer=""></script><script src="/_next/static/Ks6EI3FvHA-e3TqGlR5V4/_buildManifest.js" defer=""></script><script src="/_next/static/Ks6EI3FvHA-e3TqGlR5V4/_ssgManifest.js" defer=""></script><script src="/_next/static/Ks6EI3FvHA-e3TqGlR5V4/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="container"><link href="//fonts.googleapis.com/css?family=Cardo|Limelight" rel="stylesheet" type="text/css"/><div class="header"><header role="banner"><hgroup><h1><a href="/">pro.grammati.ca</a></h1></hgroup></header><nav role="navigation"><ul class="main-navigation"><li><a href="/blog">Blog</a></li><li><a href="/library">Library</a></li><li><a href="/about">About</a></li></ul></nav></div><div class="blog-post"><div class="blog-post-title"><h1>Microbucks</h1><br/></div><div class="blog-post-content"><p>When estimating the cost of AWS services, I like to think in microbucks.</p><p>What is a microbuck? It is one millionth of a dollar, or one ten-thousandth of a
cent.</p><p>AWS pricing can be complicated. But when you work it out, it turns out that the
cost of a lot of commonly-used, pay-per-use services can be easily estimated in
microbucks (µ$)</p><h2>Per-Service Costs</h2><p>Note: all of these estimates ignore the free tier.</p><h3>Lambda</h3><p>Lambdas cost about 1 µ$ per invocation. How so?</p><p>Making two assumptions:</p><ul><li>We use 512 MB of memory, which is pretty reasonable for many lambdas, and</li><li>We finish in under 100 ms, and so get billed for 100 ms of time.</li></ul><p>Then the cost comes out to about 0.8 µ$. Added to the per-request price of 0.2
µ$ per invocation, we get the handy rule of thumb:</p><p>1 microbuck per lambda invocation.</p><h3>API Gateway</h3><p>Calls to an HTTP API cost 1 µ$. Simple.</p><p>Calls to a REST API cost 3.5 µ$.</p><h3>DynamoDB</h3><p>With on-demand capacity, writes cost 1.25 µ$ for items under 1 kb. Reads up 4 kb
are one tenth of that, so almost free.</p><p>Storage is 0.25 µ$ per item per month, assuming 1 kb items. So 3 µ$ per year.</p><h3>Events</h3><p>Publishing to EventBridge costs 1 µ$ per event.</p><p>SQS cost 0.4 µ$, but that&#x27;s per-call. You&#x27;ll need 3 calls - publish, then read,
then ack. So it also ends up being about a microbuck per message.</p><h3>S3</h3><p>Write requests cost 5 µ$ each. Read requests are 0.4 µ$.</p><p>Storage: for 1 µ$, you can store 40 kb of data for a month.</p><h3>CloudWatch Logs</h3><p>Half a µ$ per kb logged.</p><h3>Step functions</h3><p>These are an outlier - they cost 25 µ$ per state transition. That can easily
dominate your costs.</p><p>Express workflows are priced in a completely different way - you pay 1 µ$ per
invocation, plus lambda pricing for the whole duration of the function, start to
finish. It&#x27;s not yet clear to me what you would use express workflows for, so
I&#x27;ll say no more.</p><h3>SES</h3><p>100 µ$ per email sent. Ouch.</p><h2>Examples</h2><p>Let&#x27;s say you have a pretty standard serverless app. You can
back-of-the-envelope the costs like this:</p><ul><li>Request comes in to API Gateway: 1 µ$</li><li>API Gateway invokes a lambda: 1 µ$</li><li>Lambda writes an item to DynamoDB: 1 µ$</li><li>Lambda does some logging to CloudWatch: 1 µ$</li><li>Total: 4 µ$</li></ul><p>So if your app handles a million requests, it will cost you four bucks.</p><p>Another example:</p><ul><li>Request comes in to API Gateway: 1 µ$</li><li>API Gateway invokes a lambda: 1 µ$</li><li>Lambda writes an item to DynamoDB: 1 µ$</li><li>Lambda does some logging to CloudWatch: 1 µ$</li><li>Lambda publishes an event to EventBridge 1 µ$</li><li>Another lambda consumes the event: 1 µ$</li><li>Lambda 2 writes some data to S3: 5 µ$</li><li>Lambda 2 also does some logging: 1 µ$</li><li>Total: 12 µ$</li></ul><p>So, 12 bucks per million requests.</p><p>And one more example:</p><ul><li>Request comes in to API Gateway: 1 µ$</li><li>API Gateway invokes a lambda: 1 µ$</li><li>Lambda starts a step function with 5 states / 4 transitions: 100 µ$</li><li>One of the steps sends an email: 100 µ$</li><li>The other steps do some stuff, whatever, let&#x27;s call it another 5 µ$</li><li>Total: 207 µ$</li></ul><p>The step function and the email really killed us.</p><p>It&#x27;s interesting to note that:</p><ul><li>Sending a single email can cost much more than all the other things you do in
handling a request.</li><li>Step Functions can really add up, especially if you have a retry-loop in your
state machine. Even in the happy-path, a state machine with just 5 states will
cost 100 µ$ per invocation (4 state-transitions), which is huge compared to
the simple API example above at 4 µ$. Add in a retry-loop and it can be a
whole lot more.</li></ul></div></div><footer class="footer"><p>© Chris Perkins 2022</p></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Microbucks","slug":"blog/2020-05-20-microbucks","datePublished":"2020-05-20T00:00:00.000Z","mdx":{"compiledSource":"var m=Object.defineProperty,h=Object.defineProperties;var c=Object.getOwnPropertyDescriptors;var i=Object.getOwnPropertySymbols;var s=Object.prototype.hasOwnProperty,n=Object.prototype.propertyIsEnumerable;var p=(e,t,a)=\u003et in e?m(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a,l=(e,t)=\u003e{for(var a in t||(t={}))s.call(t,a)\u0026\u0026p(e,a,t[a]);if(i)for(var a of i(t))n.call(t,a)\u0026\u0026p(e,a,t[a]);return e},r=(e,t)=\u003eh(e,c(t));var u=(e,t)=\u003e{var a={};for(var o in e)s.call(e,o)\u0026\u0026t.indexOf(o)\u003c0\u0026\u0026(a[o]=e[o]);if(e!=null\u0026\u0026i)for(var o of i(e))t.indexOf(o)\u003c0\u0026\u0026n.call(e,o)\u0026\u0026(a[o]=e[o]);return a};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(a){var o=a,{components:e}=o,t=u(o,[\"components\"]);return mdx(MDXLayout,r(l(l({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"When estimating the cost of AWS services, I like to think in microbucks.\"),mdx(\"p\",null,`What is a microbuck? It is one millionth of a dollar, or one ten-thousandth of a\ncent.`),mdx(\"p\",null,`AWS pricing can be complicated. But when you work it out, it turns out that the\ncost of a lot of commonly-used, pay-per-use services can be easily estimated in\nmicrobucks (\\xB5$)`),mdx(\"h2\",null,\"Per-Service Costs\"),mdx(\"p\",null,\"Note: all of these estimates ignore the free tier.\"),mdx(\"h3\",null,\"Lambda\"),mdx(\"p\",null,\"Lambdas cost about 1 \\xB5$ per invocation. How so?\"),mdx(\"p\",null,\"Making two assumptions:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"We use 512 MB of memory, which is pretty reasonable for many lambdas, and\"),mdx(\"li\",{parentName:\"ul\"},\"We finish in under 100 ms, and so get billed for 100 ms of time.\")),mdx(\"p\",null,`Then the cost comes out to about 0.8 \\xB5$. Added to the per-request price of 0.2\n\\xB5$ per invocation, we get the handy rule of thumb:`),mdx(\"p\",null,\"1 microbuck per lambda invocation.\"),mdx(\"h3\",null,\"API Gateway\"),mdx(\"p\",null,\"Calls to an HTTP API cost 1 \\xB5$. Simple.\"),mdx(\"p\",null,\"Calls to a REST API cost 3.5 \\xB5$.\"),mdx(\"h3\",null,\"DynamoDB\"),mdx(\"p\",null,`With on-demand capacity, writes cost 1.25 \\xB5$ for items under 1 kb. Reads up 4 kb\nare one tenth of that, so almost free.`),mdx(\"p\",null,\"Storage is 0.25 \\xB5$ per item per month, assuming 1 kb items. So 3 \\xB5$ per year.\"),mdx(\"h3\",null,\"Events\"),mdx(\"p\",null,\"Publishing to EventBridge costs 1 \\xB5$ per event.\"),mdx(\"p\",null,`SQS cost 0.4 \\xB5$, but that's per-call. You'll need 3 calls - publish, then read,\nthen ack. So it also ends up being about a microbuck per message.`),mdx(\"h3\",null,\"S3\"),mdx(\"p\",null,\"Write requests cost 5 \\xB5$ each. Read requests are 0.4 \\xB5$.\"),mdx(\"p\",null,\"Storage: for 1 \\xB5$, you can store 40 kb of data for a month.\"),mdx(\"h3\",null,\"CloudWatch Logs\"),mdx(\"p\",null,\"Half a \\xB5$ per kb logged.\"),mdx(\"h3\",null,\"Step functions\"),mdx(\"p\",null,`These are an outlier - they cost 25 \\xB5$ per state transition. That can easily\ndominate your costs.`),mdx(\"p\",null,`Express workflows are priced in a completely different way - you pay 1 \\xB5$ per\ninvocation, plus lambda pricing for the whole duration of the function, start to\nfinish. It's not yet clear to me what you would use express workflows for, so\nI'll say no more.`),mdx(\"h3\",null,\"SES\"),mdx(\"p\",null,\"100 \\xB5$ per email sent. Ouch.\"),mdx(\"h2\",null,\"Examples\"),mdx(\"p\",null,`Let's say you have a pretty standard serverless app. You can\nback-of-the-envelope the costs like this:`),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Request comes in to API Gateway: 1 \\xB5$\"),mdx(\"li\",{parentName:\"ul\"},\"API Gateway invokes a lambda: 1 \\xB5$\"),mdx(\"li\",{parentName:\"ul\"},\"Lambda writes an item to DynamoDB: 1 \\xB5$\"),mdx(\"li\",{parentName:\"ul\"},\"Lambda does some logging to CloudWatch: 1 \\xB5$\"),mdx(\"li\",{parentName:\"ul\"},\"Total: 4 \\xB5$\")),mdx(\"p\",null,\"So if your app handles a million requests, it will cost you four bucks.\"),mdx(\"p\",null,\"Another example:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Request comes in to API Gateway: 1 \\xB5$\"),mdx(\"li\",{parentName:\"ul\"},\"API Gateway invokes a lambda: 1 \\xB5$\"),mdx(\"li\",{parentName:\"ul\"},\"Lambda writes an item to DynamoDB: 1 \\xB5$\"),mdx(\"li\",{parentName:\"ul\"},\"Lambda does some logging to CloudWatch: 1 \\xB5$\"),mdx(\"li\",{parentName:\"ul\"},\"Lambda publishes an event to EventBridge 1 \\xB5$\"),mdx(\"li\",{parentName:\"ul\"},\"Another lambda consumes the event: 1 \\xB5$\"),mdx(\"li\",{parentName:\"ul\"},\"Lambda 2 writes some data to S3: 5 \\xB5$\"),mdx(\"li\",{parentName:\"ul\"},\"Lambda 2 also does some logging: 1 \\xB5$\"),mdx(\"li\",{parentName:\"ul\"},\"Total: 12 \\xB5$\")),mdx(\"p\",null,\"So, 12 bucks per million requests.\"),mdx(\"p\",null,\"And one more example:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Request comes in to API Gateway: 1 \\xB5$\"),mdx(\"li\",{parentName:\"ul\"},\"API Gateway invokes a lambda: 1 \\xB5$\"),mdx(\"li\",{parentName:\"ul\"},\"Lambda starts a step function with 5 states / 4 transitions: 100 \\xB5$\"),mdx(\"li\",{parentName:\"ul\"},\"One of the steps sends an email: 100 \\xB5$\"),mdx(\"li\",{parentName:\"ul\"},\"The other steps do some stuff, whatever, let's call it another 5 \\xB5$\"),mdx(\"li\",{parentName:\"ul\"},\"Total: 207 \\xB5$\")),mdx(\"p\",null,\"The step function and the email really killed us.\"),mdx(\"p\",null,\"It's interesting to note that:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},`Sending a single email can cost much more than all the other things you do in\nhandling a request.`),mdx(\"li\",{parentName:\"ul\"},`Step Functions can really add up, especially if you have a retry-loop in your\nstate machine. Even in the happy-path, a state machine with just 5 states will\ncost 100 \\xB5$ per invocation (4 state-transitions), which is huge compared to\nthe simple API example above at 4 \\xB5$. Add in a retry-loop and it can be a\nwhole lot more.`)))}MDXContent.isMDXComponent=!0;\n"}}},"__N_SSG":true},"page":"/blog/[blog]","query":{"blog":"2020-05-20-microbucks"},"buildId":"Ks6EI3FvHA-e3TqGlR5V4","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>