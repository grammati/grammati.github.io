<feed><id>urn:pro-grammati-ca:feed</id><updated>2016-12-10T00:00:00.000Z</updated><title type="text">pro.grammati.ca</title><link rel="self" href="http://pro.grammati.ca/atom.xml" /><entry><title>Thoughts on Visibility (in Clojure)</title><updated>2016-12-10T00:00:00.000Z</updated><author><name>Chris Perkins</name></author><link href="http://pro.grammati.ca/blog/2016/12/10/thoughts-on-visibility/" /><id>urn:pro-grammati-ca:feed:post:Thoughts on Visibility (in Clojure)</id><content type="html">&lt;p&gt;I just spent a couple of days debugging some Clojure code (most of which I wrote myself), and it was not all that pleasant.&lt;/p&gt;&lt;p&gt;I want better tools. I have for years. The tools have gotten vastly better over the years I have been doing Clojure, but we can still do much better.&lt;/p&gt;&lt;p&gt;Having just seen several great talks about tools at Clojure Conj, I'm convinced that we can do better right now. In particular:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Proto-REPL - Jason showed off exactly the kind of data-structure visualizations that I have been dreaming of for years. I sure do love me some emacs, but I could be convinced to change if this thing is good enough.&lt;/li&gt;&lt;li&gt;Sayid - Bill gave a glimpse into the future with a tool that captures a complete record of a program's execution, fully inspectable. This, too, I have been dreaming of for years. (I even started to write almost exactly the same thing myself, &lt;a href="https://github.com/grammati/rosco"&gt;here&lt;/a&gt;, but didn't get nearly as far with it as Bill has).&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;In addition, there were a &lt;em&gt;lot&lt;/em&gt; of talks about clojure.spec, and I'm embarrassed to admit that I haven't really tried it yet, but I have high hopes.&lt;/p&gt;&lt;p&gt;Finally, spectrum looks extremely promising - it's more-or-less a static type checker for Clojure.&lt;/p&gt;&lt;p&gt;In addition to all that, I'm becoming convinced that I need to make more effort to build visibility into my programs. I do plenty of logging, but poring through logs sucks. I'm not entirely sure how to go about this, but in general I'm thinking about putting in more "dev-mode only" code that captures data in various places (eg: messages received on a kafka queue) and exposes them through special, dev-mode only HTTP endpoints. I'll need to explore this to get a more concrete idea of what would be useful.&lt;/p&gt;</content></entry><entry><title>Cider Debug Wishlist</title><updated>2016-02-02T00:00:00.000Z</updated><author><name>Chris Perkins</name></author><link href="http://pro.grammati.ca/blog/2016/02/02/cider-debug-wishlist/" /><id>urn:pro-grammati-ca:feed:post:Cider Debug Wishlist</id><content type="html">&lt;h2&gt;Step In&lt;/h2&gt;&lt;p&gt;When stepping through code in the debugger, you can only step through functions that you have explicitly instrumented beforehand.&lt;/p&gt;&lt;p&gt;This is still, by far, the biggest reason that I have to attach Intellij and debug from there.&lt;/p&gt;&lt;p&gt;I'm not sure what the interface should be - hopefully something better than what edebug does, which is a bit awkward.&lt;/p&gt;&lt;h2&gt;Eval&lt;/h2&gt;&lt;p&gt;While stopped in the debugger, you can press &lt;code&gt;e&lt;/code&gt; for &lt;code&gt;eval&lt;/code&gt; (although it's not documented), but the resulting value is shown in an overlay, as if it was the value of the last expression.&lt;/p&gt;&lt;p&gt;You can work around this by evaluating &lt;code&gt;(prn thing)&lt;/code&gt; or &lt;code&gt;(pprint thing)&lt;/code&gt;, but it might be nice to have an &lt;code&gt;eval-and-pprint&lt;/code&gt; command.&lt;/p&gt;&lt;h2&gt;Overlays&lt;/h2&gt;&lt;p&gt;Overlays are used to show values. (TODO: rant about overlays). I would often rather have the values pretty-printed into a dedicated buffer, so that I can search, copy, yank, etc.&lt;/p&gt;&lt;h2&gt;Conditional Breakpoints&lt;/h2&gt;&lt;p&gt;I want conditional breakpoints!&lt;/p&gt;&lt;p&gt;Strawman:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;#break ^{:bp/condition (some expression)} (foo bar (baz))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I'm pretty sure that a reader literal only gets to operate on the single form that follows it, but I think attaching the condition as read-time metadata to the form would work.&lt;/p&gt;&lt;p&gt;Could also add a condition when instumenting a defn, perhaps with &lt;code&gt;C-u C-u C-M-x&lt;/code&gt;, then prompting for a the condition expression, which would be an expression of the arguments.&lt;/p&gt;&lt;h2&gt;Breakpoints List&lt;/h2&gt;&lt;p&gt;You can show a list of instumented functions, but it's very spartan. Should be able to jump to the function, uninstrument, etc.&lt;/p&gt;&lt;p&gt;It would also be nice to integrate this with the cider namespace browser (which itself could use some vast improvements!).&lt;/p&gt;&lt;h2&gt;Stacktrace&lt;/h2&gt;&lt;p&gt;There is now an &lt;code&gt;s&lt;/code&gt; command to show the current stacktrace. Yay!&lt;/p&gt;&lt;p&gt;It might be nice to highlight stack-frames that are instrumented, and to instrument or uninstrument functions directly from the stacktrace buffer.&lt;/p&gt;&lt;p&gt;The reason for this is that sometimes I am debugging and can see that the parameters passed to the instrumented function are not what I expected. I will want to re-run whatever I'm doing with some functions higher in the stack instrumented so I can figure out where things went wrong.&lt;/p&gt;&lt;h2&gt;Inspector&lt;/h2&gt;&lt;p&gt;The cider inspector is used to show locals while stopped in the debugger.&lt;/p&gt;&lt;p&gt;Expanding maps is tedious. It should expand maps and sequeneces inline, indented. More of a tree-like view.&lt;/p&gt;&lt;p&gt;I also want it to live-update as I step, and retain its expansion-state whenever possible.&lt;/p&gt;&lt;h2&gt;Break on Exceptions&lt;/h2&gt;&lt;p&gt;Another thing that I currently turn to Intellij for is "Break on Exception". I would love it if cider could do this.&lt;/p&gt;&lt;p&gt;I'm not quite sure how cider could implement this, given its approach of intrumenting functions one-at-a-time.&lt;/p&gt;&lt;p&gt;One option is to have an option for mass-instrumenation of functions, by walking through loaded namespaces. This could be combined with an option to instrument code in such a way that it stops in the debugger at the point where an exception is thrown. As in Intellij, you would probably want to break conditionally, based on the specific exception class.&lt;/p&gt;&lt;p&gt;Another, perhaps more ambitious option would be to also integrate an entirely different debugger, based on JPDA. There may some code to be scavenged from the old emacs clojure debugger project, which I can't quite remember the name of right now (Hugo Duncan made it).&lt;/p&gt;&lt;h2&gt;Thread&lt;/h2&gt;&lt;p&gt;I want multithreaded debugging.&lt;/p&gt;&lt;p&gt;Imagine being able to step through two functions, executing in parallel, in side-by-side emacs windows. You could play with various ways of manually interleaving execution orders to reveal threading bugs (yes, those do happen in clojure!), race conditions, etc.&lt;/p&gt;&lt;p&gt;At the moment, I don't think this works well, if at all, although I need to do some experiments to see how far off we are. There certainly appear to be some bookkeeping vars in cider-nrepl's debug namespace that are not multithread-aware.&lt;/p&gt;&lt;h2&gt;Macroexpansion&lt;/h2&gt;&lt;p&gt;It would be pretty cool to step through the macroexpanded version of a piece of code, expanded inline.&lt;/p&gt;&lt;h2&gt;Finding Your Place&lt;/h2&gt;&lt;p&gt;At the moment, it's easy to lose your debug session.&lt;/p&gt;&lt;p&gt;Sometimes while stopped at a breakpoint, I start meta-dotting my way around the code, reading some other functions, etc. Eventually, I want to continue my debugging session, but I can't remember which function or even which namespace the debugger is stopped in. I need a way to jump back to the code that I'm currently stopped in.&lt;/p&gt;&lt;h2&gt;Read Only&lt;/h2&gt;&lt;p&gt;I would prefer if files were always read-only while debugging. The fact that you can type any character you like except for &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;e&lt;/code&gt;, etc. (the debugger commands) is just weird.&lt;/p&gt;&lt;p&gt;Also, if I'm pounding on &lt;code&gt;n&lt;/code&gt; in rapid succession and hit a function that takes some time (eg: a database call), then I accidentally start typing n's into the code.&lt;/p&gt;</content></entry></feed>